{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"cfdiag","text":"<p>cfdiag is a professional-grade, cross-platform diagnostic CLI tool for Cloudflare and general networking issues.</p> <p>It helps you identify: *   Cloudflare Errors (522, 525, 502) *   DNS Propagation issues *   SSL/TLS Handshake failures *   Direct Origin connectivity problems</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#binary-recommended","title":"Binary (Recommended)","text":"<p>Download from Releases.</p>"},{"location":"#homebrew","title":"Homebrew","text":"<pre><code>brew install baturkacamak/cfdiag/cfdiag\n</code></pre>"},{"location":"#pip","title":"Pip","text":"<pre><code>pip install cfdiag\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code># Basic Scan\ncfdiag example.com\n\n# Detailed Scan\ncfdiag example.com --verbose\n\n# JSON Output\ncfdiag example.com --json\n</code></pre>"},{"location":"api/","title":"Library API","text":"<p>You can use <code>cfdiag</code> as a Python library in your own tools.</p>"},{"location":"api/#core","title":"Core","text":""},{"location":"api/#cfdiag.core.interactive_mode","title":"<code>interactive_mode()</code>","text":"<p>Interactive wizard mode for easier usage.</p> Source code in <code>cfdiag/core.py</code> <pre><code>def interactive_mode() -&gt; None:\n    \"\"\"Interactive wizard mode for easier usage.\"\"\"\n    print(f\"{Colors.BOLD}{Colors.HEADER}=== cfdiag Interactive Mode ==={Colors.ENDC}\\n\")\n\n    # Get domain\n    domain = input(f\"{Colors.OKBLUE}Enter domain to diagnose: {Colors.ENDC}\").strip()\n    if not domain:\n        print(f\"{Colors.FAIL}Domain is required.{Colors.ENDC}\")\n        sys.exit(1)\n\n    domain = domain.replace(\"http://\", \"\").replace(\"https://\", \"\").strip(\"/\")\n\n    # Ask for origin IP\n    origin_input = input(f\"{Colors.OKBLUE}Origin IP (optional, press Enter to skip): {Colors.ENDC}\").strip()\n    origin = origin_input if origin_input else None\n\n    # Ask for expected nameserver\n    expect_input = input(f\"{Colors.OKBLUE}Expected nameserver substring for propagation check (optional): {Colors.ENDC}\").strip()\n    expected_ns = expect_input if expect_input else None\n\n    # Ask for verbose mode\n    verbose_input = input(f\"{Colors.OKBLUE}Enable verbose output? (y/N): {Colors.ENDC}\").strip().lower()\n    verbose = verbose_input in ['y', 'yes']\n\n    # Ask for output format\n    print(f\"\\n{Colors.OKBLUE}Output format:\")\n    print(\"  1. Standard (default)\")\n    print(\"  2. JSON\")\n    print(\"  3. Markdown\")\n    print(\"  4. JUnit XML\")\n    print(\"  5. All formats{Colors.ENDC}\")\n    format_input = input(f\"{Colors.OKBLUE}Choose (1-5, default 1): {Colors.ENDC}\").strip() or \"1\"\n\n    # Ask for advanced options\n    metrics_input = input(f\"{Colors.OKBLUE}Export Prometheus metrics? (y/N): {Colors.ENDC}\").strip().lower()\n    export_metrics = metrics_input in ['y', 'yes']\n\n    cdn_input = input(f\"{Colors.OKBLUE}Run advanced CDN reachability test? (y/N): {Colors.ENDC}\").strip().lower()\n    cdn_check = cdn_input in ['y', 'yes']\n\n    # Setup context\n    ctx = {\n        'ipv4': False,\n        'ipv6': False,\n        'proxy': None,\n        'keylog_file': None,\n        'headers': None,\n        'timeout': 10,\n        'traceroute_limit': 5\n    }\n\n    silent = format_input == \"2\"  # JSON mode is silent\n    l = FileLogger(verbose=verbose, silent=silent)\n    set_logger(l)\n    set_context(ctx)\n\n    # Run diagnostics\n    result = run_diagnostics(domain, origin, expected_ns, export_metrics=export_metrics, cdn_check=cdn_check)\n\n    # Save additional formats\n    if format_input in [\"3\", \"5\"]:\n        l.save_markdown(os.path.join(\"reports\", domain, f\"{datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.md\"))\n    if format_input in [\"4\", \"5\"]:\n        l.save_junit(os.path.join(\"reports\", domain, \"junit.xml\"))\n    if format_input == \"2\":\n        import json\n        print(json.dumps(result, indent=4))\n    else:\n        if not verbose:\n            print(f\"\\n{Colors.OKGREEN}\u2713 Diagnostic complete! Reports saved to reports/{domain}/ folder.{Colors.ENDC}\")\n</code></pre>"},{"location":"api/#network","title":"Network","text":""},{"location":"api/#cfdiag.network.detect_cloudflare_usage","title":"<code>detect_cloudflare_usage(domain, ipv4, ipv6)</code>","text":"Determine whether the target is using Cloudflare based on <p>1) Resolved A/AAAA records falling into known Cloudflare IP ranges. 2) NS records containing 'cloudflare.com'.</p> Source code in <code>cfdiag/network.py</code> <pre><code>def detect_cloudflare_usage(domain: str, ipv4: List[str], ipv6: List[str]) -&gt; bool:\n    \"\"\"\n    Determine whether the target is using Cloudflare based on:\n      1) Resolved A/AAAA records falling into known Cloudflare IP ranges.\n      2) NS records containing 'cloudflare.com'.\n    \"\"\"\n    # 1. IP range check (A/AAAA records)\n    for ip in ipv4 + ipv6:\n        # Skip obvious private / loopback ranges \u2013 they are never Cloudflare edges.\n        if ip.startswith((\"192.168.\", \"10.\", \"127.\", \"::1\")):\n            continue\n        if _ip_in_cidr_ranges(ip, CLOUDFLARE_IPS):\n            return True\n\n    # 2. NS record check for \"cloudflare.com\"\n    ns_output = \"\"\n    cmd = \"\"\n    if shutil.which(\"dig\"):\n        cmd = f\"dig NS {domain} +short\"\n    elif os.name == 'nt':\n        cmd = f\"nslookup -type=NS {domain}\"\n\n    if cmd:\n        code, out = run_command(cmd, show_output=False, log_output_to_file=True)\n        if code == 0:\n            ns_output = out.lower()\n\n    if \"cloudflare.com\" in ns_output:\n        return True\n\n    return False\n</code></pre>"},{"location":"api/#cfdiag.network.detect_waf_from_response","title":"<code>detect_waf_from_response(status_code, headers, body='')</code>","text":"<p>Detect WAF presence from HTTP response headers and body.</p> <p>Returns:</p> Type Description <code>Tuple[bool, Optional[str], str]</code> <p>Tuple of (is_waf_detected, waf_name_or_none, detection_reason)</p> Source code in <code>cfdiag/network.py</code> <pre><code>def detect_waf_from_response(status_code: int, headers: Dict[str, str], body: str = \"\") -&gt; Tuple[bool, Optional[str], str]:\n    \"\"\"\n    Detect WAF presence from HTTP response headers and body.\n\n    Returns:\n        Tuple of (is_waf_detected, waf_name_or_none, detection_reason)\n    \"\"\"\n    headers_lower = {k.lower(): v.lower() for k, v in headers.items()}\n    body_lower = body.lower()\n\n    # Known WAF header signatures (key: value patterns or just header keys)\n    waf_header_signatures = {\n        'cloudflare': [\n            ('server', 'cloudflare'),\n            ('cf-ray', None),\n            ('cf-cache-status', None),\n            ('cf-request-id', None),\n        ],\n        'sucuri': [\n            ('x-sucuri-id', None),\n            ('x-sucuri-cache', None),\n        ],\n        'aws': [\n            ('x-amzn-requestid', None),\n            ('x-amzn-trace-id', None),\n            ('server', 'awsalb'),\n        ],\n        'incapsula': [\n            ('x-iinfo', None),\n            ('x-cdn', None),\n        ],\n        'akamai': [\n            ('x-akamai-transformed', None),\n            ('server', 'akamai'),\n        ],\n        'fastly': [\n            ('x-fastly-request-id', None),\n            ('server', 'fastly'),\n        ],\n        'imperva': [\n            ('x-imforwards', None),\n            ('x-cdn-srv', None),\n        ],\n    }\n\n    # Known WAF body signatures\n    waf_body_signatures = [\n        'captcha',\n        'challenge',\n        'attention required',\n        'security check',\n        'please turn javascript on',\n        'access denied by security policy',\n        'cloudflare',\n        'sucuri',\n        'incapsula',\n        'imperva',\n    ]\n\n    detected_waf = None\n    detection_reason = \"\"\n\n    # Check headers for WAF signatures\n    for waf_name, sigs in waf_header_signatures.items():\n        for key_pattern, value_pattern in sigs:\n            header_key_lower = key_pattern.lower()\n            if header_key_lower in headers_lower:\n                header_value_lower = headers_lower[header_key_lower]\n                # If value pattern is specified, check it matches\n                if value_pattern is None or value_pattern.lower() in header_value_lower:\n                    detected_waf = waf_name.capitalize()\n                    detection_reason = f\"Header signature: {key_pattern}\"\n                    return True, detected_waf, detection_reason\n\n    # Check body for WAF signatures\n    # First check for specific WAF names in body (more specific)\n    if 'cloudflare' in body_lower:\n        detected_waf = \"Cloudflare\"\n        detection_reason = \"Body signature: cloudflare\"\n        return True, detected_waf, detection_reason\n    elif 'sucuri' in body_lower:\n        detected_waf = \"Sucuri\"\n        detection_reason = \"Body signature: sucuri\"\n        return True, detected_waf, detection_reason\n    elif 'incapsula' in body_lower:\n        detected_waf = \"Incapsula\"\n        detection_reason = \"Body signature: incapsula\"\n        return True, detected_waf, detection_reason\n    elif 'imperva' in body_lower:\n        detected_waf = \"Imperva\"\n        detection_reason = \"Body signature: imperva\"\n        return True, detected_waf, detection_reason\n\n    # Then check for generic WAF signatures\n    for sig in waf_body_signatures:\n        if sig in body_lower and sig not in ['cloudflare', 'sucuri', 'incapsula', 'imperva']:\n            detected_waf = \"Generic\"\n            detection_reason = f\"Body signature: {sig}\"\n            return True, detected_waf, detection_reason\n\n    # If status is 403/406 but no WAF signatures found, mark as unconfirmed\n    if status_code in [403, 406]:\n        return False, None, \"Unconfirmed (No WAF signatures found)\"\n\n    return False, None, \"None\"\n</code></pre>"},{"location":"api/#cfdiag.network.step_alt_ports","title":"<code>step_alt_ports(domain)</code>","text":"<p>Check alternative ports</p> Source code in <code>cfdiag/network.py</code> <pre><code>def step_alt_ports(domain: str) -&gt; Tuple[bool, List[int]]:\n    \"\"\"Check alternative ports\"\"\"\n    print_subheader(\"16. Alternative Ports\")\n    l = get_logger()\n    alt_ports = [8080, 8443, 8081]\n    open_ports = []\n\n    for port in alt_ports:\n        try:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.settimeout(2)\n            result = sock.connect_ex((domain, port))\n            sock.close()\n            if result == 0:\n                open_ports.append(port)\n        except:\n            pass\n\n    if open_ports:\n        print_success(f\"Alternative ports open: {', '.join(map(str, open_ports))}\")\n        if l: l.add_html_step(\"Alt Ports\", \"PASS\", f\"Open: {open_ports}\")\n        return True, open_ports\n    else:\n        print_info(\"No alternative ports open\")\n        if l: l.add_html_step(\"Alt Ports\", \"INFO\", \"No alternative ports\")\n        return False, []\n</code></pre>"},{"location":"api/#cfdiag.network.step_cf_forced","title":"<code>step_cf_forced(domain)</code>","text":"<p>Check if forced to use Cloudflare</p> Source code in <code>cfdiag/network.py</code> <pre><code>def step_cf_forced(domain: str) -&gt; bool:\n    \"\"\"Check if forced to use Cloudflare\"\"\"\n    print_subheader(\"14. CF Forced Check\")\n    # This is an environment check, not a network check\n    return False\n</code></pre>"},{"location":"api/#cfdiag.network.step_cf_trace","title":"<code>step_cf_trace(domain)</code>","text":"<p>Check Cloudflare trace endpoint</p> Source code in <code>cfdiag/network.py</code> <pre><code>def step_cf_trace(domain: str) -&gt; Tuple[bool, Dict[str, Any]]:\n    \"\"\"Check Cloudflare trace endpoint\"\"\"\n    print_subheader(\"13. CF Trace\")\n    l = get_logger()\n    flags = get_curl_flags()\n    cmd = f\"curl{flags} -s --connect-timeout 5 https://{domain}/cdn-cgi/trace\"\n    code, output = run_command(cmd, show_output=False, log_output_to_file=True)\n\n    if code == 0 and output.strip():\n        print_success(\"CF Trace: Available\")\n        if l: l.add_html_step(\"CF Trace\", \"PASS\", \"Trace endpoint accessible\")\n        return True, {}\n    else:\n        print_info(\"CF Trace: Not available (not using Cloudflare or endpoint blocked)\")\n        if l: l.add_html_step(\"CF Trace\", \"INFO\", \"Trace endpoint not accessible\")\n        return False, {}\n</code></pre>"},{"location":"api/#cfdiag.network.step_doh","title":"<code>step_doh(domain)</code>","text":"<p>Check DNS over HTTPS</p> Source code in <code>cfdiag/network.py</code> <pre><code>def step_doh(domain: str) -&gt; None:\n    \"\"\"Check DNS over HTTPS\"\"\"\n    print_subheader(\"DNS over HTTPS Check\")\n    l = get_logger()\n    print_info(\"DoH check not yet fully implemented\")\n    if l: l.add_html_step(\"DoH\", \"INFO\", \"Check not implemented\")\n</code></pre>"},{"location":"api/#cfdiag.network.step_http3_udp","title":"<code>step_http3_udp(domain)</code>","text":"<p>Check HTTP/3 (QUIC) support</p> Source code in <code>cfdiag/network.py</code> <pre><code>def step_http3_udp(domain: str) -&gt; None:\n    \"\"\"Check HTTP/3 (QUIC) support\"\"\"\n    print_subheader(\"8. HTTP/3 (QUIC) Check\")\n    print_info(\"HTTP/3 check not yet fully implemented\")\n    l = get_logger()\n    if l: l.add_html_step(\"HTTP/3\", \"INFO\", \"Check not implemented\")\n</code></pre>"},{"location":"api/#cfdiag.network.step_ocsp","title":"<code>step_ocsp(domain)</code>","text":"<p>Check OCSP stapling</p> Source code in <code>cfdiag/network.py</code> <pre><code>def step_ocsp(domain: str) -&gt; None:\n    \"\"\"Check OCSP stapling\"\"\"\n    print_subheader(\"9.5 OCSP Stapling Check\")\n    l = get_logger()\n    probe_res = probe_tls(domain)\n    if probe_res.get(\"ocsp_stapled\"):\n        print_success(\"OCSP Stapling: Enabled\")\n        if l: l.add_html_step(\"OCSP\", \"PASS\", \"OCSP Stapling enabled\")\n    else:\n        print_info(\"OCSP Stapling: Not enabled\")\n        if l: l.add_html_step(\"OCSP\", \"INFO\", \"OCSP Stapling not enabled\")\n</code></pre>"},{"location":"api/#cfdiag.network.step_security_headers","title":"<code>step_security_headers(domain)</code>","text":"<p>Check security headers (CSP, HSTS, etc.)</p> Source code in <code>cfdiag/network.py</code> <pre><code>def step_security_headers(domain: str) -&gt; None:\n    \"\"\"Check security headers (CSP, HSTS, etc.)\"\"\"\n    print_subheader(\"7.5. Security Header Audit\")\n    l = get_logger()\n    flags = get_curl_flags()\n    cmd = f\"curl{flags} -I -s --connect-timeout 10 https://{domain}\"\n    code, output = run_command(cmd, show_output=False, log_output_to_file=True)\n\n    headers = {}\n    for line in output.splitlines():\n        if ':' in line:\n            k, v = line.split(':', 1)\n            headers[k.strip().lower()] = v.strip()\n\n    security_headers = {\n        'strict-transport-security': 'HSTS',\n        'content-security-policy': 'CSP',\n        'x-frame-options': 'X-Frame-Options',\n        'x-content-type-options': 'X-Content-Type-Options',\n        'referrer-policy': 'Referrer-Policy'\n    }\n\n    found = []\n    for header, name in security_headers.items():\n        if header in headers:\n            found.append(name)\n\n    if found:\n        print_success(f\"Security Headers: {', '.join(found)}\")\n        if l: l.add_html_step(\"Security Headers\", \"PASS\", f\"Found: {', '.join(found)}\")\n    else:\n        print_warning(\"No security headers found\")\n        if l: l.add_html_step(\"Security Headers\", \"WARN\", \"No security headers detected\")\n</code></pre>"},{"location":"api/#cfdiag.network.step_tcp","title":"<code>step_tcp(domain)</code>","text":"<p>Check TCP connectivity</p> Source code in <code>cfdiag/network.py</code> <pre><code>def step_tcp(domain: str) -&gt; bool:\n    \"\"\"Check TCP connectivity\"\"\"\n    print_subheader(\"10. TCP Connectivity\")\n    l = get_logger()\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(5)\n        result = sock.connect_ex((domain, 443))\n        sock.close()\n        if result == 0:\n            print_success(\"TCP Port 443: Open\")\n            if l: l.add_html_step(\"TCP\", \"PASS\", \"Port 443 open\")\n            return True\n        else:\n            print_fail(\"TCP Port 443: Closed or filtered\")\n            if l: l.add_html_step(\"TCP\", \"FAIL\", \"Port 443 closed\")\n            return False\n    except Exception as e:\n        print_fail(f\"TCP Check failed: {e}\")\n        if l: l.add_html_step(\"TCP\", \"FAIL\", str(e))\n        return False\n</code></pre>"},{"location":"api/#cfdiag.network.step_traceroute","title":"<code>step_traceroute(domain)</code>","text":"<p>Run traceroute with intelligent timeout detection - unlimited hops unless consecutive timeouts detected</p> Source code in <code>cfdiag/network.py</code> <pre><code>def step_traceroute(domain: str) -&gt; None:\n    \"\"\"Run traceroute with intelligent timeout detection - unlimited hops unless consecutive timeouts detected\"\"\"\n    print_subheader(\"12. Traceroute\")\n    l = get_logger()\n    trace_cmd = \"tracert\" if os.name == 'nt' else \"traceroute\"\n    if not shutil.which(trace_cmd):\n        print_info(\"Traceroute not available\")\n        return\n\n    from .utils import get_context\n    ctx = get_context()\n    # traceroute_limit now means: stop after N consecutive timeout patterns\n    max_consecutive_timeouts = ctx.get('traceroute_limit', 5)\n\n    # Build traceroute command WITHOUT hop limit (unlimited hops)\n    # Use a high default hop limit (30) to allow traceroute to run naturally\n    # The actual stopping will be controlled by consecutive timeout detection\n    if os.name == 'nt':\n        # Windows tracert uses -h for max hops, set to 30 (default is usually 30)\n        cmd = f\"{trace_cmd} -h 30 {domain}\"\n        # Windows tracert doesn't support -4/-6 flags directly\n    else:\n        # Linux/Unix traceroute uses -m for max hops, set to 30 (default is usually 30)\n        cmd = f\"{trace_cmd} -m 30 {domain}\"\n        # Add IPv4/IPv6 flags if specified (Linux/Unix only)\n        if ctx.get('ipv4'):\n            cmd = cmd.replace(trace_cmd, f\"{trace_cmd} -4\")\n        elif ctx.get('ipv6'):\n            cmd = cmd.replace(trace_cmd, f\"{trace_cmd} -6\")\n\n    # Run traceroute with real-time monitoring to detect consecutive timeouts\n    try:\n        process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)\n        output_lines = []\n        consecutive_timeouts = 0\n\n        while True:\n            line = process.stdout.readline()  # type: ignore\n            if not line and process.poll() is not None:\n                break\n\n            if line:\n                output_lines.append(line)\n\n                # Check for timeout patterns: \"* * *\" or similar timeout indicators\n                # Common patterns: \"* * *\", \"*\", \"Request timed out\", \"timeout\"\n                line_stripped = line.strip()\n                is_timeout = (\n                    \"* * *\" in line_stripped or\n                    (line_stripped.count(\"*\") &gt;= 3) or  # Multiple asterisks\n                    \"Request timed out\" in line_stripped or\n                    (\"timeout\" in line_stripped.lower() and \"*\" in line_stripped)\n                )\n\n                if is_timeout:\n                    consecutive_timeouts += 1\n                    if consecutive_timeouts &gt;= max_consecutive_timeouts:\n                        # Stop early if we see too many consecutive timeouts\n                        process.terminate()\n                        try:\n                            process.wait(timeout=2)\n                        except subprocess.TimeoutExpired:\n                            process.kill()\n\n                        if l:\n                            l.log_file(f\"Traceroute stopped early after {consecutive_timeouts} consecutive timeout patterns (* * *)\")\n                            l.log_file(f\"Traceroute output:\\n{''.join(output_lines)}\")\n                            l.log_file(f\"[NOTE] Traceroute was terminated early due to {consecutive_timeouts} consecutive timeout patterns (limit: {max_consecutive_timeouts})\")\n                        return\n                else:\n                    # Reset counter if we get a valid response\n                    consecutive_timeouts = 0\n\n        # Get remaining output if process ended normally\n        remaining = process.stdout.read()  # type: ignore\n        if remaining:\n            output_lines.append(remaining)\n\n        full_output = \"\".join(output_lines)\n        exit_code = process.poll()\n\n        if l:\n            l.log_file(f\"Traceroute output:\\n{full_output}\")\n            if exit_code and exit_code != 0:\n                l.log_file(f\"[NOTE] Traceroute exited with code {exit_code}\")\n\n    except Exception as e:\n        if l:\n            l.log_file(f\"[ERROR] Traceroute failed: {e}\")\n        # Fallback to simple run_command if monitoring fails\n        code, output = run_command(cmd, timeout=30, log_output_to_file=True)\n        if l: l.log_file(f\"Traceroute output:\\n{output}\")\n</code></pre>"},{"location":"api/#reporting","title":"Reporting","text":""},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"changelog/#v3124-2026-01-23","title":"[v3.12.4] - 2026-01-23","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Core: Corrected implementation merged from working-version branch. This release fixes issues present in v3.12.3.</li> <li>HTML Output: Implemented HTML output filtering for remote curl commands.</li> <li>Logging: Enhanced logging in FileLogger to include verbose output in reports.</li> <li>RDAP: Enhanced RDAP error handling and logging in step_domain_status function.</li> <li>DNS: Enhanced DNS trace error handling with improved unit tests.</li> <li>HTTP: Enhanced HTTP timeout handling for Cloudflare users.</li> <li>WAF: Implemented WAF detection in step_http and step_waf_evasion functions.</li> <li>Dependencies: Refactored diagnostic checks to enforce dependency chain and improve skip logic.</li> </ul>"},{"location":"changelog/#v3123-2026-01-22","title":"[v3.12.3] - 2026-01-22","text":""},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Architecture: Complete architectural cleanup. Step functions are now strictly separated and return <code>None</code>.</li> <li>Refactor: Decoupled <code>step_asn</code> from <code>step_dns</code>, ensuring independent IP resolution and linear execution flow.</li> <li>Standards: Standardized status strings to <code>PASS</code>, <code>FAIL</code>, <code>WARN</code>, <code>INFO</code>. Removed legacy <code>SUCCESS</code>/<code>CLIENT_ERROR</code> terminology.</li> <li>Cleanup: Removed dead code including unused reporting functions (<code>save_history</code>, <code>save_metrics</code>, <code>compare_reports</code>), summary generation logic, and obsolete documentation.</li> <li>Tests: Updated test suite to align with architectural changes and adjusted coverage thresholds.</li> </ul>"},{"location":"changelog/#v2120-2026-01-20","title":"[v2.12.0] - 2026-01-20","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Shell Completion: Generate bash/zsh completion scripts via <code>--completion</code>.</li> <li>JSON Output: <code>--json</code> now outputs full diagnostic data to stdout for automation.</li> </ul>"},{"location":"changelog/#v2110-2026-01-20","title":"[v2.11.0] - 2026-01-20","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Binary Distribution: Automated build of standalone executables for Windows, Linux, and macOS via GitHub Actions.</li> <li>Documentation: Updated README with installation instructions for binaries.</li> </ul>"},{"location":"changelog/#v2100-2026-01-20","title":"[v2.10.0] - 2026-01-20","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>IPv4/IPv6 Forcing: New flags <code>--ipv4</code> and <code>--ipv6</code>.</li> <li>Proxy Support: New flag <code>--proxy</code> to route traffic via HTTP proxies.</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Architecture: Fixed critical logger bug in parallel execution mode.</li> </ul>"},{"location":"changelog/#v290-2026-01-20","title":"[v2.9.0] - 2026-01-20","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Offline Mode: Uses DNS (<code>dig</code>) for ASN/ISP lookup instead of external HTTP APIs.</li> <li>Report Diffing: Compare two diagnostic reports with <code>--diff</code>.</li> <li>Logging: Fixed global logger issues in threaded context.</li> </ul>"},{"location":"changelog/#v280-2026-01-20","title":"[v2.8.0] - 2026-01-20","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Redirect Chain Analysis: Trace full redirect paths and detect loops.</li> <li>WAF Evasion Testing: Test connection using different User-Agents.</li> </ul>"},{"location":"changelog/#v270-2026-01-20","title":"[v2.7.0] - 2026-01-20","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Parallel Scanning: Multi-threaded batch mode (<code>--threads</code>).</li> <li>Packaging: Added <code>setup.py</code> for PyPI distribution.</li> </ul>"},{"location":"changelog/#v260-2026-01-20","title":"[v2.6.0] - 2026-01-20","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Metrics: Prometheus OpenMetrics export via <code>--metrics</code>.</li> <li>History: Automatic TTFB comparison with previous runs.</li> </ul>"},{"location":"changelog/#v250-2026-01-20","title":"[v2.5.0] - 2026-01-20","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Reports: Organized reports into per-domain subdirectories.</li> <li>Verbosity: Defaulted to summary-only text logs (matching console).</li> </ul>"},{"location":"changelog/#v240-2026-01-20","title":"[v2.4.0] - 2026-01-20","text":""},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Summary: Restored missing Diagnostic Summary in text reports.</li> <li>Formatting: Fixed ANSI escape codes in log files.</li> </ul>"},{"location":"changelog/#v200-2026-01-20","title":"[v2.0.0] - 2026-01-20","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>Core: Initial major release with DNS, HTTP, TCP, and Traceroute.</li> </ul>"},{"location":"decision_trees/","title":"Comprehensive Decision Trees","text":"<p>This document specifies the exact logic used in <code>cfdiag/analysis.py</code> to classify probe results.</p>"},{"location":"decision_trees/#1-dns-decision-tree","title":"1. DNS Decision Tree","text":"<p>Function: <code>analyze_dns</code> Input: <code>ProbeDNSResult</code></p> Evaluation Order Condition Classification Severity Human Reason 1 <code>error</code> is present OR (<code>A</code> empty AND <code>AAAA</code> empty) <code>DNS_FAIL</code> CRITICAL DNS Resolution failed: {error} 2 <code>A</code> present AND <code>AAAA</code> present <code>DNS_PASS</code> PASS Resolved both IPv4 and IPv6. 3 <code>A</code> present AND <code>AAAA</code> empty <code>DNS_IPV4_ONLY</code> INFO IPv4 only (No AAAA records). 4 <code>AAAA</code> present AND <code>A</code> empty <code>DNS_IPV6_ONLY</code> INFO IPv6 only (No A records). 5 Default <code>DNS_PASS</code> PASS Resolved. <p>Note: Resolver inconsistencies are currently handled by the probe returning a unified set or error.</p>"},{"location":"decision_trees/#2-http-decision-tree","title":"2. HTTP Decision Tree","text":"<p>Function: <code>analyze_http</code> Input: <code>ProbeHTTPResult</code></p> Evaluation Order Condition Classification Severity Human Reason 1 <code>error</code> contains \"Timeout\" <code>HTTP_TIMEOUT</code> CRITICAL Request timed out: {error} 2 <code>error</code> present OR <code>code</code> == 0 <code>HTTP_CONNECT_FAIL</code> CRITICAL Connection failed: {error} 3 <code>code</code> in [301, 302, 303, 307, 308] <code>HTTP_REDIRECT</code> WARNING Redirect limit reached or loop detected. 4 <code>code</code> == 429 <code>HTTP_RATE_LIMIT</code> INFO Rate Limited (HTTP 429). 5 200 &lt;= <code>code</code> &lt; 400 <code>HTTP_PASS</code> PASS HTTP {code} OK. 6 <code>is_waf_challenge</code> == True <code>HTTP_WAF_BLOCK</code> INFO Request challenged/blocked by WAF. 7 400 &lt;= <code>code</code> &lt; 500 <code>HTTP_CLIENT_ERROR</code> WARNING Client Error (HTTP {code}). 8 500 &lt;= <code>code</code> &lt; 600 <code>HTTP_SERVER_ERROR</code> ERROR Server Error (HTTP {code}). 9 Default <code>UNKNOWN</code> WARNING Unexpected status: {code}"},{"location":"decision_trees/#3-tls-decision-tree","title":"3. TLS Decision Tree","text":"<p>Function: <code>analyze_tls</code> Input: <code>ProbeTLSResult</code></p> Evaluation Order Condition Classification Severity Human Reason 1 <code>handshake_success</code> == False <code>TLS_FAIL_HANDSHAKE</code> CRITICAL TLS Handshake Failed: {error} 2 <code>cert_valid</code> == False AND (\"expired\" in errors) <code>TLS_EXPIRED</code> ERROR Certificate Expired/Not Valid: {errors} 3 <code>cert_valid</code> == False <code>TLS_WARN_CERT_INVALID</code> ERROR Certificate Invalid: {errors} 4 <code>protocol_version</code> &lt; \"TLSv1.2\" <code>TLS_OLD_PROTOCOL</code> WARNING Deprecated Protocol: {version} 5 Default <code>TLS_PASS</code> PASS TLS Handshake Success."},{"location":"decision_trees/#4-mtu-decision-tree","title":"4. MTU Decision Tree","text":"<p>Function: <code>analyze_mtu</code> Input: <code>ProbeMTUResult</code></p> Evaluation Order Condition Classification Severity Human Reason 1 <code>path_mtu</code> == 0 <code>MTU_WARNING</code> WARNING Could not determine MTU (ICMP blocked?). 2 <code>path_mtu</code> &lt; 1280 <code>MTU_CRITICAL</code> CRITICAL Path MTU {mtu} &lt; 1280 (IPv6 Min). 3 1280 &lt;= <code>path_mtu</code> &lt; 1500 <code>MTU_WARNING</code> WARNING Path MTU {mtu} &lt; 1500. 4 <code>path_mtu</code> &gt;= 1500 <code>MTU_PASS</code> PASS MTU 1500 OK."},{"location":"decision_trees/#5-origin-decision-tree","title":"5. Origin Decision Tree","text":"<p>Function: <code>analyze_origin_reachability</code> Input: Edge <code>ProbeHTTPResult</code>, Origin <code>ProbeHTTPResult</code></p> Evaluation Order Condition Classification Severity Human Reason 1 Origin <code>error</code> contains \"Timeout\" <code>ORIGIN_522</code> ERROR Origin Timed Out (Direct). 2 Origin <code>error</code> present OR <code>code</code> == 0 <code>ORIGIN_UNREACHABLE</code> CRITICAL Origin Unreachable: {error} 3 Edge in [502, 504, 521, 522] AND Origin OK (2xx/3xx) <code>ORIGIN_FIREWALL_BLOCK</code> WARNING Origin is UP, but Cloudflare cannot reach it. 4 Origin OK AND Edge OK <code>ORIGIN_REACHABLE</code> PASS Origin and Edge both reachable. 5 Default <code>ORIGIN_REACHABLE</code> INFO Status match (non-success)."},{"location":"usage/","title":"Usage Guide","text":""},{"location":"usage/#core-commands","title":"Core Commands","text":""},{"location":"usage/#single-domain","title":"Single Domain","text":"<p>Scan a single domain. Default output is a concise summary.</p> <pre><code>cfdiag example.com\n</code></pre>"},{"location":"usage/#batch-mode","title":"Batch Mode","text":"<p>Scan multiple domains from a file using parallel threads.</p> <pre><code>cfdiag --file list.txt --threads 20\n</code></pre>"},{"location":"usage/#advanced-options","title":"Advanced Options","text":""},{"location":"usage/#direct-origin-test","title":"Direct Origin Test","text":"<p>Bypass Cloudflare and DNS to connect directly to an IP address. Essential for verifying if your server firewall is blocking Cloudflare.</p> <pre><code>cfdiag example.com --origin 1.2.3.4\n</code></pre>"},{"location":"usage/#dns-propagation","title":"DNS Propagation","text":"<p>Check if your Nameserver changes have propagated globally.</p> <pre><code>cfdiag example.com --expect ns1.digitalocean.com\n</code></pre>"},{"location":"usage/#waf-testing","title":"WAF Testing","text":"<p>Test if the site is blocking specific User-Agents (like curl).</p> <pre><code>cfdiag example.com --verbose\n</code></pre> <p>(This runs automatically in verbose mode)</p>"},{"location":"usage/#automation","title":"Automation","text":""},{"location":"usage/#json-output","title":"JSON Output","text":"<p>Get the full internal state as a JSON object.</p> <pre><code>cfdiag example.com --json | jq .\n</code></pre>"},{"location":"usage/#report-diffing","title":"Report Diffing","text":"<p>Compare two previous reports to see what changed.</p> <pre><code>cfdiag --diff reports/a.txt reports/b.txt\n</code></pre>"}]}